问题：setState()更新状态是同步还是异步？
答：
    根据情况而定：
    1）执行setState()的位置？
        在react控制的回调函数中：生命周期钩子/react事件监听回调
        非react控制的异步回调函数中：定时器回调/原生事件监听回调/promise回调/...
    2）异步或同步？
        react相关回调中：异步
        其他一部回调中：同步
    
    关于异步的setState()
        1)多次调用如何处理？
            setState({}):合并更新一次状态，只调用一次render()更新界面--状态更新和界面更新都合并
            setState(fn):更新多次状态，但只调用一次render()更新界面--状态更新没有合并，但界面更新合并
        2)如何得到异步更新后的状态数据？
            在setState()的callback回调函数中


示例1：
class StateTest extends React.Component{
    state ={
        count : 0,
    }

    //1、react事件监听回调：setState()是异步更新
    update1=()=>{
        console.log('update1 setState()之前',this.state.count)  //count : 0
        this.setState(state=>({count : state.count+1}))  //render ： count : 1
        console.log('update1 setState()之后',this.state.count)  //count : 0
    }

    //2、react生命周期钩子：setState()是异步更新
    componentDidMount(){
        console.log('componentDidMount setState()之前',this.state.count)  //count : 0
        this.setState(state=>({count : state.count+1}))  //render ： count : 1
        console.log('componentDidMount setState()之后',this.state.count)  //count : 0
    }
    

    //3、定时器回调函数：setState()是同步更新
    update2=()=>{
        setTimeout(()=>{
            console.log('setTimeout setState()之前',this.state.count)  //count : 0
            this.setState(state=>({count : state.count+1}))  //render ： count : 1
            console.log('setTimeout setState()之后',this.state.count) //count : 1
        })
    }

    //4、原生事件监听回调：setState()是同步更新
    update3=()=>{
        const h2 = this.refs.count;
        h2.onclick = () =>{
            console.log('onclick setState()之前',this.state.count)  //count : 0
            this.setState(state=>({count : state.count+1}))  //render ： count : 1
            console.log('onclick setState()之后',this.state.count)  //count : 1
        }
    }

    //5、promise函数回调：setState()是同步更新
    update4=()=>{
        Promise.resolved().then(value=>{
            console.log('Promise setState()之前',this.state.count)  //count : 0
            this.setState(state=>({count : state.count+1}))  //render ： count : 1
            console.log('Promise setState()之后',this.state.count)  //count : 1
        })
    }

    //6、多个setState(fn)在一起作用的效果：函数
    update5=()=>{
        console.log('Promise setState()之前',this.state.count) //count : 1
        this.setState(state=>({count : state.count+1}))  
        console.log('Promise setState()之后',this.state.count) //count : 1

        console.log('Promise setState()之前2',this.state.count) //count : 1
        this.setState(state=>({count : state.count+1}))  
        console.log('Promise setState()之后2',this.state.count) //count : 1
        //函数模式下每次setState()均更新，故每次count都+1
        //只render一次(渲染合并)，且render后count：3
    }

    //7、多个setState({})在一起作用的效果：对象
    update6=()=>{
        console.log('Promise setState()之前',this.state.count)  //count : 1
        this.setState({count : this.state.count + 1})  
        console.log('Promise setState()之后',this.state.count)  //count : 1

        console.log('Promise setState()之前2',this.state.count) //count : 1
        this.setState({count : this.state.count + 1}) 
        console.log('Promise setState()之后2',this.state.count) //count : 1
        //对象模式下二次setState()合并为一次，故count仍为1
        //只render一次(渲染合并)，且render后count：2
    }

    //8、setState(fn)、setState({})在一起作用的效果：混合
    update7=()=>{
        console.log('Promise setState()之前',this.state.count)  //count : 1
        this.setState({count : this.state.count + 1})  
        console.log('Promise setState()之后',this.state.count)  //count : 1

        console.log('Promise setState()之前2',this.state.count)  //count : 1
        this.setState(state=>({count : state.count+1})) 
        console.log('Promise setState()之后2',this.state.count)  //count : 1
        //对象模式下在未渲染前count均为1，而函数模式下获取的是当前状态下的count值，即为2
        //只render一次(渲染合并)，且render后count：3
    }
    render(){
        const {count} = this.state.coount;
        return(
            <div>
                <h2 ref='count'>{count}</h2>
                <Button onClick={this.update1}>更新1</Button>---
                <Button onClick={this.update2}>更新2</Button>&nbsp;
                <Button onClick={this.update3}>更新3</Button>&nbsp;
                <Button onClick={this.update4}>更新4</Button>---
                <Button onClick={this.update5}>更新5</Button>&nbsp;
                <Button onClick={this.update6}>更新6</Button>&nbsp;
                <Button onClick={this.update7}>更新7</Button>&nbsp;
            </div>
        )
    }
}


示例2：setState()面试题
class StateTest extends React.Component{
    state= {
        count : 0,
    }

    componentDidMount(){

        //异步,setState({})更新合并，渲染合并
        this.setState({count:this.state.count + 1})
        this.setState({count:this.state.count + 1}) //count：1
        console.log(this.state.count) //2==>count:0

        //异步,setState(fn)更新多次，渲染合并
        this.setState(state=>({count : state.count + 1})) //count：2
        this.setState(state=>({count : state.count + 1})) //count：3
        console.log(this.state.count) //3==>count:0
        //两个异步setState()之后要渲染一次，4==>render:count : 3

        setTimeout(()=>{//同步
            this.setState({count:this.state.count + 1}) //9==》render：count:6
            console.log('setTimeout',this.state.count)  //10==》count:6

            this.setState({count:this.state.count + 1}) //11==》render：count:7
            console.log('setTimeout',this.state.count)  //12==》count:7
        },0)

        //同步：Promise和setTimeout两个函数之间，Promise先执行
        Promise.resolved().then(value=>{//同步
            this.setState({count:this.state.count + 1}) //5==》render：count:4
            console.log('promise',this.state.count) //6==》count:4

            this.setState({count:this.state.count + 1}) //7==》render：count:5
            console.log('promise',this.state.count) //8==》count:5
        })
    }

    render(){
        const count = this.state.count;
        console.log('render',count)  //1==>count:0
        return(
            <div>
                <p>{count}</p>
            </div>
        )
    }
}
